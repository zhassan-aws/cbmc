<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: analyses</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__analyses.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">analyses</div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="autotoc_md2"></a>
Folder analyses</h1>
<p>This contains the abstract interpretation frameworks and several static analyses that instantiate them.</p>
<h1><a class="anchor" id="analyses-frameworks"></a>
Frameworks:</h1>
<p>There are currently three abstract interpretation frameworks provided in this directory. <a class="el" href="group__analyses.html#analyses-ait">Abstract interpreter framework (ait)</a>, <a class="el" href="group__analyses.html#analyses-flow-insensitive-analysis">Flow-insensitive analysis (flow_insensitive_analysist)</a>, and the deprecated and obsolete <a class="el" href="group__analyses.html#analyses-static-analysist">Old Abstract interpreter framework (static_analysist)</a>.</p>
<h2><a class="anchor" id="analyses-ait"></a>
Abstract interpreter framework (ait)</h2>
<p>This abstract interpretation framework is the focus of current active development, and is where most scalability improvements will happen. It should be used as the basis for any new development work. This framework is provided by <a class="el" href="classait.html">ait</a>. This analysis framework is currently location sensitive (meaning there is one abstract domain per code location) and is designed to be run after the function pointer removal and return removal passes. There is ongoing work to make this framework also support context sensitivity.</p>
<h2><a class="anchor" id="analyses-static-analysist"></a>
Old Abstract interpreter framework (static_analysist)</h2>
<p>The obsolete static analysis framework <a class="el" href="classstatic__analysist.html">static_analysist</a> is only used by <a class="el" href="value__set__analysis_8h.html#a39b39e38c9c3e60e3a1fb667659bce56">value_set_analysist</a>. This abstract interpretation framework is deprecated in favour of <a class="el" href="group__analyses.html#analyses-ait">Abstract interpreter framework (ait)</a>, and should not be used as the basis for new code. This framework is location sensitive (one domain per code location), but is able to be run before function pointer removal and return removal phases.</p>
<h2><a class="anchor" id="analyses-flow-insensitive-analysis"></a>
Flow-insensitive analysis (flow_insensitive_analysist)</h2>
<p>Framework for flow-insensitive analyses. Maintains a single global abstract value which instructions are invited to transform in turn. Unsound (terminates too early) if (a) there are two or more instructions that incrementally reach a fixed point, for example by walking a chain of pointers and updating a points-to set, but (b) those instructions are separated by instructions that don't update the abstract value (for example, SKIP instructions). Therefore, not recommended for new code.</p>
<p>Only current user in-tree is <a class="el" href="classvalue__set__analysis__fit.html">value_set_analysis_fit</a>.</p>
<h1><a class="anchor" id="analyses-specific-analyses"></a>
Specific analyses:</h1>
<h2><a class="anchor" id="analyses-call-graph"></a>
Call graph and associated helpers (call_grapht)</h2>
<p>A [<a href="https://en.wikipedia.org/wiki/Call_graph">https://en.wikipedia.org/wiki/Call_graph</a>](call graph) for a GOTO model or GOTO functions collection. <a class="el" href="classcall__grapht.html">call_grapht</a> implements a basic call graph, but can also export the graph in <a class="el" href="classgrapht.html">grapht</a> format, which permits more advanced graph algorithms to be applied; see <a class="el" href="call__graph__helpers_8h.html">call_graph_helpers.h</a> for functions that work with the <a class="el" href="classgrapht.html">grapht</a> representation.</p>
<h2><a class="anchor" id="analyses-dominator"></a>
Dominator analysis (cfg_dominators_templatet)</h2>
<p>A [<a href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">https://en.wikipedia.org/wiki/Dominator_(graph_theory)</a>](dominator analysis) for a GOTO model or GOTO functions collection. Briefly, if a CFG node is dominated by {A, B, C} then in order to reach this node control must have flowed through all of A, B and C; similarly if it is post-dominated by {D, E, F} then after we pass through this node we will inevitably reach all of D, E and F eventually if the program terminates.</p>
<p>This is useful for e.g. checking against introducing a redundant check: if we have a <code>const int *x</code> parameter and wish to introduce a null check at node Y, then we can also mark it checked at all the nodes that Y dominates, as at those program points it has necessarily already been checked.</p>
<p>This analysis defines <code>cfg_dominatorst</code> (dominator analysis) and <code>cfg_post_dominatorst</code> (post-dominator analysis). Run these analyses using <code>operator()(const goto_programt &amp;)</code>. Alternatively, the template can be instantiated with a different type that can be used with <code><a class="el" href="classprocedure__local__cfg__baset.html">procedure_local_cfg_baset</a></code> &ndash; this is done by <code>natural_loops_mutablet</code> using (non-const) <code><a class="el" href="classgoto__programt.html" title="A generic container class for the GOTO intermediate representation of one function.">goto_programt</a></code>, and by <code><a class="el" href="classjava__bytecode__convert__methodt.html">java_bytecode_convert_methodt</a></code> to apply the dominator algorithm to its Java bytecode representation.</p>
<p><code><a class="el" href="classcfg__dominators__templatet.html#a7adb5843236067a4153a2786bbf505e6" title="Print the result of the dominator computation.">cfg_dominators_templatet::output</a></code> is a good place to check how to query the dominators it has found.</p>
<h2><a class="anchor" id="analyses-constant-propagation"></a>
Constant propagation (\ref constant_propagator_ait)</h2>
<p>A simple, unsound constant propagator. Replaces RHS symbol expressions (variable reads) with their values when they appear to have a unique value at a particular program point. Unsound with respect to pointer operations on the left-hand side of assignments.</p>
<h2><a class="anchor" id="analyses-taint"></a>
Taint analysis (custom_bitvector_analysist)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-dependence-graph"></a>
Data- and control-dependence analysis (dependence_grapht)</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Dependence graph</h3>
<p>Implemented in <code><a class="el" href="dependence__graph_8h.html" title="Field-Sensitive Program Dependence Analysis, Litvak et al., FSE 2010.">src/analyses/dependence_graph.h</a>(cpp)</code>. It is a graph and an abstract interpreter at the same time. The abstract interpretation nature allows a dependence graph to [build itself](Construction) (the graph) from a given GOTO program.</p>
<p>A dependence graph extends the class <code>grapht</code> with <code><a class="el" href="structdep__nodet.html">dep_nodet</a></code> as the type of nodes (see <code><a class="el" href="graph_8h.html" title="A Template Class for Graphs.">src/util/graph.h</a></code> for more details about [graph representation]("../util/README.md")). The <code><a class="el" href="structdep__nodet.html">dep_nodet</a></code> extends <code><a class="el" href="classgraph__nodet.html" title="This class represents a node in a directed graph.">graph_nodet</a>&lt;<a class="el" href="classdep__edget.html">dep_edget</a>&gt;</code> with an iterator to a GOTO program instruction. It means that each graph node corresponds to a particular program instruction. A labelled edge <code>(u, v)</code> of a dependence graph expresses a dependency of the program instruction corresponding to node <code>u</code> on the program instruction corresponding to node <code>v</code>. The label of the edge (data of the type <code><a class="el" href="classdep__edget.html">dep_edget</a></code> attached to the edge) denotes the kind of dependency. It can be <code>control-dependency</code>, <code>data-dependency</code>, or both. <br  />
</p>
<h4><a class="anchor" id="autotoc_md4"></a>
Control dependency</h4>
<p>An instruction <code>j</code> corresponding to node <code>v</code> is control-dependent on instruction <code>i</code> corresponding to node <code>u</code> if and only if <code>j</code> post-dominates at least one but not all successors instructions of <code>i</code>.</p>
<p>An instruction <code>j</code> post-dominates an instruction <code>i</code> if and only if each execution path going through <code>i</code> eventually reaches <code>j</code>.</p>
<p>Post-dominators analysis is implemented in <code><a class="el" href="cfg__dominators_8h.html" title="Compute dominators for CFG of goto_function.">src/analyses/cfg_dominators.h</a>(cpp)</code>.</p>
<h4><a class="anchor" id="autotoc_md5"></a>
Data dependency</h4>
<p>The instruction <code>j</code> corresponding to node <code>v</code> is data-dependent on the instruction <code>i</code> corresponding to node <code>u</code> if and only if <code>j</code> may read data from the memory location defined (i.e. written) by <code>i</code>.</p>
<p>The reaching definitions analysis is used together with the read-write ranges analysis to check whether one instruction may read data writen by another instruction. For more details see <code><a class="el" href="reaching__definitions_8h.html" title="Range-based reaching definitions analysis (following Field- Sensitive Program Dependence Analysis,...">src/analyses/reaching_definitions.h</a>(cpp)</code> and <code><a class="el" href="goto__rw_8h.html">src/analyses/goto_rw.h</a>(cpp)</code>.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
Construction</h4>
<p>The dependence graph extends the standard abstract interpreter class <code>ait</code> with post-dominators analysis and reaching definitions analysis. The domain of the abstract interpreter is defined in the class <code><a class="el" href="classdep__graph__domaint.html">dep_graph_domaint</a></code>.</p>
<p>For each instruction <code>i</code> an instance of <code><a class="el" href="classdep__graph__domaint.html">dep_graph_domaint</a></code> associated with <code>i</code> is created. The instance stores a set <code>control_deps</code> of program instructions the instruction <code>i</code> depends on via control-dependency, and a set <code>data_deps</code> of program instructions the instruction <code>i</code> depends on via data-dependency. These sets are updated (increased) during the computation, until a fix-point is reached.</p>
<p>The construction of a dependence graph is started by calling its <code>initialize</code> method and then, once a fix-point is reached by the abstract interpreter, the method <code>finalize</code> converts data in the interpreter's domain (i.e. from <code><a class="el" href="classdep__graph__domaint.html">dep_graph_domaint</a></code> instances) into edges of the graph. Nodes of the graph are created during the run of the abstract interpreter; they are linked to the corresponding program instructions.</p>
<h2><a class="anchor" id="analyses-dirtyt"></a>
Address-taken lvalue analysis (dirtyt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-const-cast-removal"></a>
const_cast removal analysis (does_remove_constt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-escape"></a>
Escape analysis (escape_analysist)</h2>
<p>This is a simple [<a href="https://en.wikipedia.org/wiki/Escape_analysis">https://en.wikipedia.org/wiki/Escape_analysis</a>](escape analysis). It is intended to implement <code>__CPROVER_cleanup</code> instructions, which say that a given cleanup function should be run when a particular object goes out of scope. Examples of its usage can be seen in <code>ansi-c/library/stdio.c</code> and <code>ansi-c/library/pthread_lib.c</code>, where it is used to introduce assertions that a <code>FILE*</code> going out of scope has been <code>fclose</code>'d or similarly that a <code>pthread_mutex*</code> has been properly destroyed.</p>
<p>For example <code>f = fopen("/tmp/hello", "wb"); __CPROVER_cleanup(f, check_closed);</code> should result in a call to <code>check_closed(f)</code> or <code>check_closed()</code> (depending on whether it has an argument) when <code>f</code> and all its aliases go out of scope.</p>
<p>The alias analysis is a simple union-find algorithm, and can introduce cleanup calls too soon (i.e. before all aliases are really gone), so this overestimates the possible problems caused by escaping pointers.</p>
<p>Note this differs from a typical escape analysis, which would conservatively (over-)estimate the objects that may be reachable when (e.g.) a function exits; this <em>underestimates</em> the reachable objects in order to favour false positives over false negatives when testing for missing close operations.</p>
<h2><a class="anchor" id="analyses-global-may-alias"></a>
Global may-alias analysis (global_may_aliast)</h2>
<p>This is a pointer alias analysis (analysing the memory locations a pointer expression may point to, and finding when two pointer expressions refer to the same storage locations). It is flow-insensitive, meaning that it computes what memory locations pointer expressions may refer to at any time during the program execution. It's called may-alias, because it looks for aliasing that may occur during program execution (compared to analysis for aliasing that must occur). It's an over-approximating analysis.</p>
<h2><a class="anchor" id="analyses-rwt"></a>
Read-write range analysis (goto_rwt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-invariant-propagation"></a>
Invariant propagation (invariant_propagationt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-is-threaded"></a>
Multithreaded program detection (is_threadedt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-pointer-classification"></a>
Pointer classification analysis (is-heap-pointer, might-be-null, etc – local_bitvector_analysist)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-cfg"></a>
Control-flow graph (local_cfgt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-local-may-alias"></a>
Local may-alias analysis (local_may_aliast)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-safe-dereference"></a>
Safe dereference analysis (local_safe_pointerst)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-locals"></a>
Address-taken locals analysis (localst)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-natural-loop"></a>
Natural loop analysis (natural_loops_templatet)</h2>
<p>A natural loop is when the nodes and edges of a graph make one self-encapsulating circle (implemented in /ref <a class="el" href="classnatural__loops__templatet.html" title="Main driver for working out if a class (normally goto_programt) has any natural loops.">natural_loops_templatet</a>) with no incoming edges from external nodes. For example A -&gt; B -&gt; C -&gt; D -&gt; A is a natural loop, but if B has an incoming edge from X, then it isn't a natural loop, because X is an external node. Outgoing edges don't affect the natural-ness of a loop.</p>
<p>/ref <a class="el" href="classcfg__dominators__templatet.html" title="Dominator graph.">cfg_dominators_templatet</a> provides the dominator analysis used to determine if a nodes children can only be reached through itself and is thus part of a natural loop, and whose specifics is covered in a separate subsection.</p>
<p>A basic description for how a natural loop works is here: <a href="https://web.cs.wpi.edu/~kal/PLT/PLT8.6.4.html">https://web.cs.wpi.edu/~kal/PLT/PLT8.6.4.html</a></p>
<h2><a class="anchor" id="analyses-reaching-definitions"></a>
Reaching definitions (reaching_definitions_analysist)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-uncaught-exceptions"></a>
Uncaught exceptions analysis (uncaught_exceptions_domaint)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-uninitialized-locals"></a>
Uninitialized locals analysis (uninitialized_analysist)</h2>
<p>To be documented.</p>
<h1><a class="anchor" id="analyses-transformations"></a>
Transformations (arguably in the wrong directory):</h1>
<h2><a class="anchor" id="analyses-goto-checkt"></a>
Pointer / overflow / other check insertion (goto_checkt)</h2>
<p>To be documented.</p>
<h2><a class="anchor" id="analyses-interval-analysis"></a>
Integer interval analysis – both an analysis and a transformation</h2>
<p><a class="el" href="interval__analysis_8h.html#ac596f29ee60594342a0c09a6ad4a1e1c">interval_analysis</a> interprets instructions of the input <a class="el" href="classgoto__modelt.html">goto_modelt</a> over the <a class="el" href="classinterval__domaint.html">interval_domaint</a>, evaluates variables for each program location (as intervals) and instruments the program with assumptions representing the over-approximation of variable values. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
