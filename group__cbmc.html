<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CBMC: cbmc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CBMC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__cbmc.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">cbmc</div>  </div>
</div><!--header-->
<div class="contents">
<h1><a class="anchor" id="autotoc_md10"></a>
Folder CBMC</h1>
<dl class="section author"><dt>Author</dt><dd>Martin Brain</dd></dl>
<p>This contains the first full application. CBMC is a bounded model checker that uses the front ends (<code>ansi-c</code>, <code>cpp</code>, goto-program or others) to create a goto-program, <code>goto-symex</code> to unwind the loops the given number of times and to produce and equation system and finally <code>solvers</code> to find a counter-example (technically, <code>goto-symex</code> is then used to construct the counter-example trace).</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Architecture</h2>
<p>CBMC operates in three phases:</p>
<ol type="1">
<li>Parse command-line options; convert passed source files into a GOTO model (for more detail see <a class="el" href="background-concepts.html#AST_section">AST</a>).</li>
<li>Run <code>goto-symex</code> to turn the GOTO model into a SAT or SMT equation (for more detail see <a class="el" href="group__goto-symex.html">goto-symex</a>).</li>
<li>Solve the equation and report results (described here, but see <a class="el" href="background-concepts.html#BMC_section">Bounded model checking</a> for more information).</li>
</ol>
<p>The GOTO model is generated using <code>initialize_goto_model</code>; see documentaton in the <code>goto-programs/</code> directory. Goto-symex is similarly documented in its own directory.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Equation solving</h2>
<p>The class <code>bmct</code> is responsible for solving the equation, generated by goto-symex, which represents the assertions or goals it is being asked to show can be hit or satisfied (or prove that can't be done).</p>
<p>For example, given an input program <code>f(int x, int y) { assert(x + y % 3 == 1); assert(x % y == 0); }</code> then goto- symex would produce a formula something like <code>F1 + F2 % 3 != 1 OR (F1 + F2 % 3 == 1 AND F1 % F2 != 0)</code>, where <code>F</code>-variables are free. The precise expression of that formula depends on CBMC's command-line configuration: for some backends it will lower the arithmetic operations into bitwise operations; other backends understand arithmetic and so they will remain as-is. See <code>cbmc_solverst</code> for details of how a backend solver is selected, constructed and configured.</p>
<p>Whatever precise backend representation is used, CBMC controls solving the formula using two different possible procedures:</p>
<ol type="1">
<li>When <code>--stop-on-fail</code> is passed on the command-line, the formula is solved once to find any violated assertion. This is implemented directly in class <code>bmct</code>. If the formula is satisfiable, a counter-example trace is generated.</li>
<li>When <code>--stop-on-fail</code> is not passed, BMC is run in "all-properties" mode. This categorises the assertions into groups that represent the same property, and the solver is run repeatedly to try to satisfy each property at least once. This is implemented in <code>bmc_all_propertiest</code>.</li>
</ol>
<p>For example, in the all-properties case, if the provided formula had five assertions, <code>A1 ... A5</code>, and <code>A1</code> and <code>A2</code> were instances of the same property as were <code>A4</code> and <code>A5</code>, then initially the solver would simply be asked to satisfy <code>A1 | A2 | A3 | A4 | A5</code>, but if its first solution gave an answer for <code>A1</code> only, then the solver would be called again asking for a solution to <code>A3 | A4 | A5</code>, <code>A1</code> having been satisfied and <code>A2</code> being considered irrelevant because it is an instance of the same property as <code>A1</code>. If the solver came back with a solution hitting <code>A3</code> then it would be asked again to solve for <code>A4 | A5</code>, and so on until either every property is satisfied or the solver responds that a solution is impossible.</p>
<p>Generally assertions are considered instances of the same property if they are derived from the same source code statement: for example, <code>assert(x == 1); assert(x == 2);</code> would be considered two distinct properties, while <code>for(int i = 1; i &lt;= 2; ++i) assert(x == i);</code> would generate two instances of the same property. This is because assertions are categorised by their <code>source_location-&gt;get_property_id()</code> field, which in turn is set per static instruction by <code><a class="el" href="set__properties_8cpp.html" title="Set Properties.">goto-programs/set_properties.cpp</a></code>. Assertions that are generated by other mechanism may categorise their properties differently.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Coverage mode</h3>
<p>There is one further BMC mode that differs more fundamentally: when <code>--cover</code> is passed, assertions in the program text are converted into assumptions (these must hold for control flow to proceed past them, but are not goals for the equation solver; In cases where this behaviour is undesirable you can pass the <code>--cover-failed-assertions</code> which makes coverage checking continue even for paths where assertions fail), while new <code>assert(false)</code> statements are added throughout the source program representing coverage goals. The equation solving process then proceeds the same as in all-properties mode. Coverage solving is implemented by <code>bmc_covert</code>, but is structurally practically identical to <code>bmc_all_propertiest</code>&ndash; only the reporting differs (goals are called "covered" rather than "failed").</p>
<h2><a class="anchor" id="autotoc_md14"></a>
Reporting</h2>
<p>By default CBMC will report its findings by listing which assertions passed (could not be violated) or failed (could be violated), or which coverage goals were satisfiable or unsatisfiable, depending on its mode of operation. However if <code>--trace</code> is passed then it will print a full program trace indicating how each assertion was violated. This is constructed using <code>build_goto_trace</code>, which queries the backend asking what value was chosen for each program variable on the path from the start of the program to the relevant assertion. For more details on how the trace is populated see the documentation for <code>build_goto_trace</code> for <code><a class="el" href="classdecision__proceduret.html#a728b2bdb614c52b357bf83859ede0566" title="Return expr with variables replaced by values from satisfying assignment if available.">prop_convt::get</a></code>, the function used to query the backend.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
Path-symex</h2>
<p>CBMC supports running goto-symex in "path explorer" mode, which alters the simple GOTO model, goto-symex, equation solving sequence described above by incrementally running goto-symex to produce a formula describing <em>part</em> of a program, trying to solve that partial formula to satisfy some properties (or achieve some coverage, as appropriate), before re-entering symex to examine other properties. For example, given a simple program <code>if(x) assert(y); else assert(z);</code>, standard CBMC would generate a single formula of the form <code>(x &amp;&amp; !y) || (!x &amp;&amp; !z)</code>, while in path-explorer mode it might generate a partial formula <code>x &amp;&amp; !y</code> and try solving that before even considering the <code>!x</code> case. This should have the same end result as without the special path-explorer mode, but could achieve the result faster in <code>--stop-on-fail</code> mode or allow salvaging a partial result from an otherwise excessively time- or memory-consuming run in all-properties mode.</p>
<p>For more details on path-symex see the classes <code><a class="el" href="classgoto__symext.html" title="The main class for the forward symbolic simulator.">goto_symext</a></code> and <code>path_explorert</code>. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
