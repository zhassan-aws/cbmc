<h1>NAME</h1>
<p>goto-harness - Generate environments for symbolic analysis</p>
<h1>SYNOPSIS</h1>
<dl>
<dt><strong>goto-harness [-?] [-h] [--help]</strong></dt>
<dd><p>show help</p>
</dd>
<dt><strong>goto-harness <strong>--version</strong></strong></dt>
<dd><p>show version</p>
</dd>
<dt><strong>goto-harness <em>in</em> <em>out</em> --harness-function-name <em>name</em> --harness-type <em>harness-type</em> [<strong>harness-options</strong>]</strong></dt>
<dd><p>build harness for <em>in</em> and write harness to <em>out</em>; the harness is printed as C code, if <em>out</em> has a .c suffix, else a GOTO binary including the harness is generated</p>
</dd>
</dl>
<h1>DESCRIPTION</h1>
<p><strong>goto-harness</strong> constructs functions that set up an appropriate environment before calling functions under analysis. This is most useful when trying to analyze an isolated unit of a program.</p>
<p>A typical sequence of tool invocations is as follows. Given a C program <em>program.c</em>, we generate a harness for function <em>test_function</em>:</p>
<pre><code># Compile the program
goto-cc program.c -o program.gb
# Run goto-harness to produce harness file
goto-harness --harness-type call-function --harness-function-name generated_harness_test_function
  --function test_function program.gb harness.c
# Run the checks targeting the generated harness
cbmc --pointer-check harness.c --function generated_harness_test_function</code></pre>
<p><strong>goto-harness</strong> has two main modes of operation. First,function-call harnesses, which automatically synthesize an environment without having any information about the program state. Second, memory-snapshot harnesses, in which case <strong>goto-harness</strong> loads an existing program state as generated by <strong>memory-analyzer</strong>(1) and selectively havocs some variables.</p>
<h1>OPTIONS</h1>
<dl>
<dt><strong>--harness-function-name</strong> <em>name</em></dt>
<dd><p>Use <em>name</em> as the name of the harness function that is generated, i.e., the new entry point.</p>
</dd>
<dt><strong>--harness-type</strong> [<strong>call-function</strong>|<strong>initialize-with-memory-snapshot</strong>]</dt>
<dd><p>Select the type of harness to generate. In addition to options applicable to both harness generators, each of them also has dedicated options that are described below.</p>
</dd>
</dl>
<h2>Common generator options</h2>
<dl>
<dt><strong>--min-null-tree-depth</strong> <em>N</em></dt>
<dd><p>Set the minimum level at which a pointer can first be <strong>NULL</strong> in a recursively non-deterministically initialized struct to <em>N</em>. Defaults to 1.</p>
</dd>
<dt><strong>--max-nondet-tree-depth</strong> <em>N</em></dt>
<dd><p>Set the maximum height of the non-deterministic object tree to <em>N</em>. At that level, all pointers will be set to <strong>NULL</strong>. Defaults to 2.</p>
</dd>
<dt><strong>--min-array-size</strong> <em>N</em></dt>
<dd><p>Set the minimum size of arrays of non-constant size allocated by the harness to <em>N</em>. Defaults to 1.</p>
</dd>
<dt><strong>--max-array-size</strong> N</dt>
<dd><p>Set the maximum size of arrays of non-constant size allocated by the harness to <em>N</em>. Defaults to 2.</p>
</dd>
<dt><strong>--nondet-globals</strong></dt>
<dd><p>Set global variables to non-deterministic values in harness.</p>
</dd>
<dt><strong>--havoc-member</strong> <em>member-expr</em></dt>
<dd><p>Non-deterministically initialize <em>member-expr</em> of some global object (may be given multiple times).</p>
</dd>
<dt><strong>--function-pointer-can-be-null</strong> <em>function-name</em></dt>
<dd><p>Name of parameters of the target function or of global variables of function-pointer type that can non-deterministically be set to <strong>NULL</strong>.</p>
</dd>
</dl>
<h2>Function harness generator (<strong>--harness-type call-function</strong>):</h2>
<dl>
<dt><strong>--function</strong> <em>function-name</em></dt>
<dd><p>Generate an environment to call function <em>function-name</em>, which the harness will then call.</p>
</dd>
<dt><strong>--treat-pointer-as-array</strong> <em>p</em></dt>
<dd><p>Treat the (pointer-typed) function parameter with name <em>p</em> as an array.</p>
</dd>
<dt><strong>--associated-array-size</strong> <em>array_name</em>:<em>size_name</em></dt>
<dd><p>Set the function parameter <em>size_name</em> to the size of the array parameter <em>array_name</em> (implies <strong>--treat-pointer-as-array </strong><em>array_name</em>).</p>
</dd>
<dt><strong>--treat-pointers-equal</strong> <em>p</em>,<em>q</em>,<em>r</em>[;<em>s</em>,<em>t</em>]</dt>
<dd><p>Assume the pointer-typed function parameters <em>q</em> and <em>r</em> are equal to parameter <em>p</em>, and <em>s</em> equal to <em>t</em>, and so on.</p>
</dd>
<dt><strong>--treat-pointers-equal-maybe</strong></dt>
<dd><p>Function parameter equality is non-deterministic.</p>
</dd>
<dt><strong>--treat-pointer-as-cstring</strong> <em>p</em></dt>
<dd><p>Treat the function parameter with the name <em>p</em> as a string of characters.</p>
</dd>
</dl>
<h2>Memory snapshot harness generator (<strong>--harness-type initialise-from-memory-snapshot</strong>):</h2>
<dl>
<dt><strong>--memory-snapshot</strong> <em>file</em></dt>
<dd><p>Initialize memory from JSON memory snapshot stored in <em>file</em>.</p>
</dd>
<dt><strong>--initial-goto-location</strong> <em>func</em>[:<em>n</em>]</dt>
<dd><p>Use function <em>func</em> and GOTO binary location number <em>n</em> as entry point.</p>
</dd>
<dt><strong>--initial-source-location</strong> <em>file:n</em></dt>
<dd><p>Use given file name <em>file</em> and line number <em>n in that file as entry</em> point.</p>
</dd>
<dt><strong>--havoc-variables</strong> <em>vars</em></dt>
<dd><p>Non-deterministically initialize all symbols named <em>vars</em>.</p>
</dd>
<dt><strong>--pointer-as-array</strong> <em>p</em></dt>
<dd><p>Treat the global pointer with name <em>p</em> as an array.</p>
</dd>
<dt><strong>--size-of-array</strong> <em>array_name</em>:<em>size_name</em></dt>
<dd><p>Set the variable <em>size_name</em> to the size of the array variable <em>array_name</em> (implies <strong>--pointer-as-array </strong><em>array_name</em>).</p>
</dd>
</dl>
<h1>ENVIRONMENT</h1>
<p>All tools honor the TMPDIR environment variable when generating temporary files and directories.</p>
<h1>BUGS</h1>
<p>If you encounter a problem please create an issue at <strong>https://github.com/diffblue/cbmc/issues</strong></p>
<h1>SEE ALSO</h1>
<p><strong>cbmc</strong>(1), <strong>goto-cc</strong>(1), <strong>memory-analyzer</strong>(1)</p>
<h1>COPYRIGHT</h1>
<p>2019, Diffblue</p>
